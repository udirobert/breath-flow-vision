/**
 * Consolidated Flow Hook
 * Single source of truth for all Flow blockchain functionality
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import BaseFlowClient from '@/lib/flow/clients/base-client';
import NFTClient from '@/lib/flow/clients/nft-client';
import TransactionClient from '@/lib/flow/clients/transaction-client';
import type {
  FlowConfig,
  FlowState,
  FlowUser,
  COAInfo,
  BreathingPatternAttributes,
  NFTMetadata,
  RoyaltyInfo,
  BreathingPatternNFT,
  MarketplaceListing,
  PurchaseResult,
  BatchTransactionResult,
  EVMBatchCall,
  FlowAccount,
  TransactionStatus,
  FlowTransactionResult
} from '@/lib/flow/types';

interface UseFlowConfig {
  network?: 'testnet' | 'mainnet' | 'emulator';
  autoConnect?: boolean;
  enableCOA?: boolean;
}

interface UseFlowReturn {
  // State
  state: FlowState;
  user: FlowUser | null;
  coaInfo: COAInfo | null;
  
  // Loading states
  isLoading: boolean;
  isConnecting: boolean;
  isMinting: boolean;
  isTransacting: boolean;
  
  // Error handling
  error: string | null;
  
  // Core actions
  initialize: () => Promise<void>;
  connect: () => Promise<void>;
  disconnect: () => Promise<void>;
  
  // Account management
  setupAccount: () => Promise<string>;
  getAccountInfo: (address?: string) => Promise<FlowAccount>;
  
  // NFT operations
  mintBreathingPattern: (
    attributes: BreathingPatternAttributes,
    metadata: NFTMetadata,
    recipient?: string,
    royalties?: RoyaltyInfo[]
  ) => Promise<string>;
  transferNFT: (nftId: string, recipient: string) => Promise<string>;
  getNFTs: (address?: string) => Promise<BreathingPatternNFT[]>;
  getNFT: (nftId: string, address?: string) => Promise<BreathingPatternNFT | null>;
  
  // Batch operations
  batchMintPatterns: (
    patterns: Array<{
      attributes: BreathingPatternAttributes;
      metadata: NFTMetadata;
      recipient?: string;
      royalties?: RoyaltyInfo[];
    }>
  ) => Promise<string[]>;
  
  // Transaction management
  executeTransaction: (script: string, args?: any[]) => Promise<FlowTransactionResult>;
  getTransactionStatus: (txId: string) => Promise<TransactionStatus>;
  waitForTransaction: (txId: string) => Promise<FlowTransactionResult>;
  
  // EVM/COA operations
  executeEVMBatch: (calls: EVMBatchCall[]) => Promise<BatchTransactionResult>;
  getCOAInfo: () => Promise<COAInfo | null>;
  
  // Utilities
  clearError: () => void;
  refreshData: () => Promise<void>;
  dispose: () => void;
}

export const useFlow = (config: UseFlowConfig = {}): UseFlowReturn => {
  const {
    network = 'testnet',
    autoConnect = false,
    enableCOA = false
  } = config;
  
  // Client instances
  const baseClient = useRef<BaseFlowClient>(BaseFlowClient.getInstance());
  const nftClient = useRef<NFTClient>(new NFTClient());
  const transactionClient = useRef<TransactionClient>(new TransactionClient());
  
  // State
  const [state, setState] = useState<FlowState>({
    isInitialized: false,
    isConnected: false,
    isLoading: false,
    error: null,
    user: null,
    coaInfo: null,
  });
  
  const [user, setUser] = useState<FlowUser | null>(null);
  const [coaInfo, setCOAInfo] = useState<COAInfo | null>(null);
  
  // Loading states
  const [isLoading, setIsLoading] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [isMinting, setIsMinting] = useState(false);
  const [isTransacting, setIsTransacting] = useState(false);
  
  // Error handling
  const [error, setError] = useState<string | null>(null);
  
  // User subscription
  const userUnsubscribe = useRef<(() => void) | null>(null);
  
  /**
   * Initialize Flow client
   */
  const initialize = useCallback(async () => {
    if (state.isInitialized) {
      return;
    }
    
    setIsLoading(true);
    setError(null);
    
    try {
      const flowConfig: FlowConfig = {
        network,
        accessNode: network === 'testnet' 
          ? 'https://rest-testnet.onflow.org'
          : 'https://rest-mainnet.onflow.org',
        discoveryWallet: network === 'testnet'
          ? 'https://fcl-discovery.onflow.org/testnet/authn'
          : 'https://fcl-discovery.onflow.org/authn',
        contractAddress: network === 'testnet' 
          ? '0xf8d6e0586b0a20c7'
          : '0x1234567890abcdef', // Replace with mainnet address
        fungibleTokenAddress: network === 'testnet'
          ? '0x9a0766d93b6608b7'
          : '0xf233dcee88fe0abe',
        flowTokenAddress: network === 'testnet'
          ? '0x7e60df042a9c0868'
          : '0x1654653399040a61',
      };
      
      await baseClient.current.initialize(flowConfig);
      
      // Subscribe to user changes
      userUnsubscribe.current = baseClient.current.subscribeToUser((user) => {
        setUser(user);
        setState(prev => ({
          ...prev,
          user,
          isConnected: user?.loggedIn || false,
        }));
      });
      
      setState(prev => ({
        ...prev,
        isInitialized: true,
      }));
      
      // Auto-connect if requested
      if (autoConnect) {
        await connect();
      }
      
      console.log('Flow client initialized');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Flow initialization failed';
      setError(errorMessage);
      setState(prev => ({ ...prev, error: errorMessage }));
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [network, autoConnect]);
  
  /**
   * Connect to Flow wallet
   */
  const connect = useCallback(async () => {
    if (!state.isInitialized) {
      await initialize();
    }
    
    setIsConnecting(true);
    setError(null);
    
    try {
      await baseClient.current.authenticate();
      
      // Get COA info if enabled
      if (enableCOA) {
        const coa = await getCOAInfo();
        setCOAInfo(coa);
      }
      
      console.log('Connected to Flow wallet');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Connection failed';
      setError(errorMessage);
      throw error;
    } finally {
      setIsConnecting(false);
    }
  }, [state.isInitialized, enableCOA, initialize]);
  
  /**
   * Disconnect from Flow wallet
   */
  const disconnect = useCallback(async () => {
    try {
      await baseClient.current.unauthenticate();
      setUser(null);
      setCOAInfo(null);
      setState(prev => ({
        ...prev,
        isConnected: false,
        user: null,
        coaInfo: null,
      }));
      
      console.log('Disconnected from Flow wallet');
    } catch (error) {
      console.error('Disconnect error:', error);
    }
  }, []);
  
  /**
   * Setup account for NFT collection
   */
  const setupAccount = useCallback(async (): Promise<string> => {
    if (!state.isConnected) {
      throw new Error('Not connected to Flow wallet');
    }
    
    setIsTransacting(true);
    try {
      return await nftClient.current.setupAccount();
    } finally {
      setIsTransacting(false);
    }
  }, [state.isConnected]);
  
  /**
   * Get account information
   */
  const getAccountInfo = useCallback(async (address?: string): Promise<FlowAccount> => {
    const targetAddress = address || user?.addr;
    if (!targetAddress) {
      throw new Error('No address provided and user not connected');
    }
    
    return baseClient.current.getAccount(targetAddress);
  }, [user?.addr]);
  
  /**
   * Mint breathing pattern NFT
   */
  const mintBreathingPattern = useCallback(async (
    attributes: BreathingPatternAttributes,
    metadata: NFTMetadata,
    recipient?: string,
    royalties: RoyaltyInfo[] = []
  ): Promise<string> => {
    if (!state.isConnected || !user?.addr) {
      throw new Error('Not connected to Flow wallet');
    }
    
    setIsMinting(true);
    try {
      const targetRecipient = recipient || user.addr;
      return await nftClient.current.mintBreathingPattern(
        attributes,
        metadata,
        targetRecipient,
        royalties
      );
    } finally {
      setIsMinting(false);
    }
  }, [state.isConnected, user?.addr]);
  
  /**
   * Transfer NFT
   */
  const transferNFT = useCallback(async (nftId: string, recipient: string): Promise<string> => {
    if (!state.isConnected) {
      throw new Error('Not connected to Flow wallet');
    }
    
    setIsTransacting(true);
    try {
      return await nftClient.current.transferNFT(nftId, recipient);
    } finally {
      setIsTransacting(false);
    }
  }, [state.isConnected]);
  
  /**
   * Get NFTs for an account
   */
  const getNFTs = useCallback(async (address?: string): Promise<BreathingPatternNFT[]> => {
    const targetAddress = address || user?.addr;
    if (!targetAddress) {
      return [];
    }
    
    return nftClient.current.getAllNFTs(targetAddress);
  }, [user?.addr]);
  
  /**
   * Get single NFT
   */
  const getNFT = useCallback(async (nftId: string, address?: string): Promise<BreathingPatternNFT | null> => {
    const targetAddress = address || user?.addr;
    if (!targetAddress) {
      return null;
    }
    
    return nftClient.current.getNFTMetadata(targetAddress, nftId);
  }, [user?.addr]);
  
  /**
   * Batch mint patterns
   */
  const batchMintPatterns = useCallback(async (
    patterns: Array<{
      attributes: BreathingPatternAttributes;
      metadata: NFTMetadata;
      recipient?: string;
      royalties?: RoyaltyInfo[];
    }>
  ): Promise<string[]> => {
    if (!state.isConnected || !user?.addr) {
      throw new Error('Not connected to Flow wallet');
    }
    
    setIsMinting(true);
    try {
      const patternsWithRecipients = patterns.map(pattern => ({
        ...pattern,
        recipient: pattern.recipient || user.addr!,
        royalties: pattern.royalties || [],
      }));
      
      return await nftClient.current.batchMintPatterns(patternsWithRecipients);
    } finally {
      setIsMinting(false);
    }
  }, [state.isConnected, user?.addr]);
  
  /**
   * Execute transaction
   */
  const executeTransaction = useCallback(async (
    script: string,
    args: any[] = []
  ): Promise<FlowTransactionResult> => {
    if (!state.isConnected) {
      throw new Error('Not connected to Flow wallet');
    }
    
    setIsTransacting(true);
    try {
      return await transactionClient.current.executeTransaction(script, args);
    } finally {
      setIsTransacting(false);
    }
  }, [state.isConnected]);
  
  /**
   * Get transaction status
   */
  const getTransactionStatus = useCallback(async (txId: string): Promise<TransactionStatus> => {
    return transactionClient.current.getTransactionStatus(txId);
  }, []);
  
  /**
   * Wait for transaction
   */
  const waitForTransaction = useCallback(async (txId: string): Promise<FlowTransactionResult> => {
    return baseClient.current.waitForTransaction(txId);
  }, []);
  
  /**
   * Execute EVM batch calls
   */
  const executeEVMBatch = useCallback(async (calls: EVMBatchCall[]): Promise<BatchTransactionResult> => {
    if (!state.isConnected) {
      throw new Error('Not connected to Flow wallet');
    }
    
    setIsTransacting(true);
    try {
      return await transactionClient.current.executeEVMBatchCalls(calls);
    } finally {
      setIsTransacting(false);
    }
  }, [state.isConnected]);
  
  /**
   * Get COA information
   */
  const getCOAInfo = useCallback(async (): Promise<COAInfo | null> => {
    if (!user?.addr) {
      return null;
    }
    
    try {
      // This would query COA information from Flow
      // For now, return mock data
      return {
        address: `${user.addr}-coa`,
        balance: 0,
        isInitialized: true,
      };
    } catch (error) {
      console.error('Failed to get COA info:', error);
      return null;
    }
  }, [user?.addr]);
  
  /**
   * Clear error
   */
  const clearError = useCallback(() => {
    setError(null);
    setState(prev => ({ ...prev, error: null }));
  }, []);
  
  /**
   * Refresh data
   */
  const refreshData = useCallback(async () => {
    if (!state.isConnected || !user?.addr) {
      return;
    }
    
    try {
      // Refresh COA info if enabled
      if (enableCOA) {
        const coa = await getCOAInfo();
        setCOAInfo(coa);
      }
      
      // Could refresh other data here
    } catch (error) {
      console.error('Failed to refresh data:', error);
    }
  }, [state.isConnected, user?.addr, enableCOA, getCOAInfo]);
  
  /**
   * Dispose of resources
   */
  const dispose = useCallback(() => {
    if (userUnsubscribe.current) {
      userUnsubscribe.current();
      userUnsubscribe.current = null;
    }
    
    baseClient.current.dispose();
    
    setState({
      isInitialized: false,
      isConnected: false,
      isLoading: false,
      error: null,
      user: null,
      coaInfo: null,
    });
    
    setUser(null);
    setCOAInfo(null);
    setError(null);
    
    console.log('Flow client disposed');
  }, []);
  
  // Initialize on mount
  useEffect(() => {
    initialize().catch(console.error);
    
    return () => {
      if (userUnsubscribe.current) {
        userUnsubscribe.current();
      }
    };
  }, [initialize]);
  
  // Update state when user changes
  useEffect(() => {
    setState(prev => ({
      ...prev,
      user,
      isConnected: user?.loggedIn || false,
    }));
  }, [user]);
  
  return {
    // State
    state,
    user,
    coaInfo,
    
    // Loading states
    isLoading,
    isConnecting,
    isMinting,
    isTransacting,
    
    // Error handling
    error,
    
    // Core actions
    initialize,
    connect,
    disconnect,
    
    // Account management
    setupAccount,
    getAccountInfo,
    
    // NFT operations
    mintBreathingPattern,
    transferNFT,
    getNFTs,
    getNFT,
    
    // Batch operations
    batchMintPatterns,
    
    // Transaction management
    executeTransaction,
    getTransactionStatus,
    waitForTransaction,
    
    // EVM/COA operations
    executeEVMBatch,
    getCOAInfo,
    
    // Utilities
    clearError,
    refreshData,
    dispose,
  };
};